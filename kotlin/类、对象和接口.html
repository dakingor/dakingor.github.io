<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>类、对象和接口 | 大坚博客</title>
    <meta name="description" content="现在还远远没有达到需要拼智商的地步">
    <link rel="icon" href="/img/favicon.ico">
    
    <link rel="preload" href="/assets/css/styles.bb1fe17d.css" as="style"><link rel="preload" href="/assets/js/app.bb1fe17d.js" as="script"><link rel="preload" href="/assets/js/66.24bd90de.js" as="script"><link rel="prefetch" href="/assets/css/1.styles.b05fc641.css"><link rel="prefetch" href="/assets/css/2.styles.a2bd3099.css"><link rel="prefetch" href="/assets/js/1.b05fc641.js"><link rel="prefetch" href="/assets/js/10.326ff491.js"><link rel="prefetch" href="/assets/js/11.9241fc7b.js"><link rel="prefetch" href="/assets/js/12.7acf36a5.js"><link rel="prefetch" href="/assets/js/13.ec549dd5.js"><link rel="prefetch" href="/assets/js/14.28942eba.js"><link rel="prefetch" href="/assets/js/15.e903c1ca.js"><link rel="prefetch" href="/assets/js/16.4d7ab5b5.js"><link rel="prefetch" href="/assets/js/17.36afdc36.js"><link rel="prefetch" href="/assets/js/18.cac2535e.js"><link rel="prefetch" href="/assets/js/19.cd2f75e9.js"><link rel="prefetch" href="/assets/js/2.a2bd3099.js"><link rel="prefetch" href="/assets/js/20.bf313935.js"><link rel="prefetch" href="/assets/js/21.31b36d89.js"><link rel="prefetch" href="/assets/js/22.0361f270.js"><link rel="prefetch" href="/assets/js/23.1b3f1574.js"><link rel="prefetch" href="/assets/js/24.4d491f2a.js"><link rel="prefetch" href="/assets/js/25.52f1876f.js"><link rel="prefetch" href="/assets/js/26.e08e41e4.js"><link rel="prefetch" href="/assets/js/27.4bbac78e.js"><link rel="prefetch" href="/assets/js/28.b5bd620c.js"><link rel="prefetch" href="/assets/js/29.84b65be3.js"><link rel="prefetch" href="/assets/js/3.c091e437.js"><link rel="prefetch" href="/assets/js/30.fe84dfad.js"><link rel="prefetch" href="/assets/js/31.166d5bc3.js"><link rel="prefetch" href="/assets/js/32.d65d9239.js"><link rel="prefetch" href="/assets/js/33.583bc596.js"><link rel="prefetch" href="/assets/js/34.6b83f133.js"><link rel="prefetch" href="/assets/js/35.49d1569f.js"><link rel="prefetch" href="/assets/js/36.0446fb7e.js"><link rel="prefetch" href="/assets/js/37.5fbd12a4.js"><link rel="prefetch" href="/assets/js/38.1b808891.js"><link rel="prefetch" href="/assets/js/39.3b1c557a.js"><link rel="prefetch" href="/assets/js/4.fb6903e4.js"><link rel="prefetch" href="/assets/js/40.ac5b164f.js"><link rel="prefetch" href="/assets/js/41.45b078e5.js"><link rel="prefetch" href="/assets/js/42.d40844bf.js"><link rel="prefetch" href="/assets/js/43.9009d6e3.js"><link rel="prefetch" href="/assets/js/44.1e61fc92.js"><link rel="prefetch" href="/assets/js/45.9424e6d8.js"><link rel="prefetch" href="/assets/js/46.efbee1cd.js"><link rel="prefetch" href="/assets/js/47.cee8ae47.js"><link rel="prefetch" href="/assets/js/48.3d5e7cb5.js"><link rel="prefetch" href="/assets/js/49.22238313.js"><link rel="prefetch" href="/assets/js/5.8891e232.js"><link rel="prefetch" href="/assets/js/50.4affbe35.js"><link rel="prefetch" href="/assets/js/51.fdb6ae2c.js"><link rel="prefetch" href="/assets/js/52.30127554.js"><link rel="prefetch" href="/assets/js/53.0dacde79.js"><link rel="prefetch" href="/assets/js/54.e2815542.js"><link rel="prefetch" href="/assets/js/55.83d95da2.js"><link rel="prefetch" href="/assets/js/56.fd6cfa75.js"><link rel="prefetch" href="/assets/js/57.64041257.js"><link rel="prefetch" href="/assets/js/58.feb49a9c.js"><link rel="prefetch" href="/assets/js/59.dc8df387.js"><link rel="prefetch" href="/assets/js/6.d54c1117.js"><link rel="prefetch" href="/assets/js/60.631c04b3.js"><link rel="prefetch" href="/assets/js/61.32aea37e.js"><link rel="prefetch" href="/assets/js/62.5cfec479.js"><link rel="prefetch" href="/assets/js/63.1433dd8f.js"><link rel="prefetch" href="/assets/js/64.ad33ff3d.js"><link rel="prefetch" href="/assets/js/65.701a8222.js"><link rel="prefetch" href="/assets/js/67.d396f2ec.js"><link rel="prefetch" href="/assets/js/68.2afd7019.js"><link rel="prefetch" href="/assets/js/69.05781e5f.js"><link rel="prefetch" href="/assets/js/7.1b94b949.js"><link rel="prefetch" href="/assets/js/70.2cf85943.js"><link rel="prefetch" href="/assets/js/71.aab07104.js"><link rel="prefetch" href="/assets/js/72.1533ead8.js"><link rel="prefetch" href="/assets/js/73.4e5dc4da.js"><link rel="prefetch" href="/assets/js/74.e77dfcb1.js"><link rel="prefetch" href="/assets/js/75.e8e4c83e.js"><link rel="prefetch" href="/assets/js/76.ce341a40.js"><link rel="prefetch" href="/assets/js/77.c2342e89.js"><link rel="prefetch" href="/assets/js/78.a56458f9.js"><link rel="prefetch" href="/assets/js/79.6407212c.js"><link rel="prefetch" href="/assets/js/8.f8c818df.js"><link rel="prefetch" href="/assets/js/80.6554cb4c.js"><link rel="prefetch" href="/assets/js/81.84c710c0.js"><link rel="prefetch" href="/assets/js/82.32cdc5bb.js"><link rel="prefetch" href="/assets/js/83.e08a0de0.js"><link rel="prefetch" href="/assets/js/84.59fefb9d.js"><link rel="prefetch" href="/assets/js/85.af63859c.js"><link rel="prefetch" href="/assets/js/86.513e36a1.js"><link rel="prefetch" href="/assets/js/87.c45c0b70.js"><link rel="prefetch" href="/assets/js/88.92b080af.js"><link rel="prefetch" href="/assets/js/89.ad5aec24.js"><link rel="prefetch" href="/assets/js/9.6d13d821.js"><link rel="prefetch" href="/assets/js/90.a5156631.js"><link rel="prefetch" href="/assets/js/91.fac5ac80.js"><link rel="prefetch" href="/assets/js/92.07aa1e42.js"><link rel="prefetch" href="/assets/js/93.c5f9a0d5.js"><link rel="prefetch" href="/assets/js/94.e05d5d7e.js"><link rel="prefetch" href="/assets/js/95.fea62791.js"><link rel="prefetch" href="/assets/js/96.449a8e88.js"><link rel="prefetch" href="/assets/js/97.94f2a5fd.js">
    <link rel="stylesheet" href="/assets/css/1.styles.b05fc641.css"><link rel="stylesheet" href="/assets/css/2.styles.a2bd3099.css"><link rel="stylesheet" href="/assets/css/styles.bb1fe17d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">大坚博客</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">客户端</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/android/Activity生命周期.html" class="nav-link">Android</a></li><li class="dropdown-item"><!----> <a href="/html/CSS的创建与表现.html" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/vue/" class="nav-link">Vue</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">服务端</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/spring/Spring.html" class="nav-link">Spring</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/redis/" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/mysql/" class="nav-link">MySQL</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">语言</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/kotlin/Kotlin语法基础.html" class="nav-link">Kotlin</a></li><li class="dropdown-item"><!----> <a href="/java/Java平台.html" class="nav-link">Java</a></li><li class="dropdown-item"><!----> <a href="/c/类型、运算符与表达式.html" class="nav-link">C</a></li><li class="dropdown-item"><!----> <a href="/javascript/" class="nav-link">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/python/" class="nav-link">Python</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">编程</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/design-pattern/设计模式基础.html" class="nav-link">设计模式</a></li><li class="dropdown-item"><!----> <a href="/data-structure/" class="nav-link">数据结构</a></li><li class="dropdown-item"><!----> <a href="/network-and-security/" class="nav-link">网络与安全</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">系统与工具</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/linux/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/mac/Homebrew.html" class="nav-link">Mac</a></li><li class="dropdown-item"><!----> <a href="/gradle/" class="nav-link">Gradle</a></li><li class="dropdown-item"><!----> <a href="/docker/" class="nav-link">Docker</a></li><li class="dropdown-item"><!----> <a href="/tool/" class="nav-link">其他</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">多媒体</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/opencv/搭建OpenCV Android项目.html" class="nav-link">OpenCV</a></li><li class="dropdown-item"><!----> <a href="/ffmpeg/macOS上编译FFmpeg.html" class="nav-link">FFmpeg</a></li></ul></div></div><div class="nav-item"><a href="/about-me/" class="nav-link">关于我</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">客户端</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/android/Activity生命周期.html" class="nav-link">Android</a></li><li class="dropdown-item"><!----> <a href="/html/CSS的创建与表现.html" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/vue/" class="nav-link">Vue</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">服务端</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/spring/Spring.html" class="nav-link">Spring</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/redis/" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/mysql/" class="nav-link">MySQL</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">语言</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/kotlin/Kotlin语法基础.html" class="nav-link">Kotlin</a></li><li class="dropdown-item"><!----> <a href="/java/Java平台.html" class="nav-link">Java</a></li><li class="dropdown-item"><!----> <a href="/c/类型、运算符与表达式.html" class="nav-link">C</a></li><li class="dropdown-item"><!----> <a href="/javascript/" class="nav-link">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/python/" class="nav-link">Python</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">编程</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/design-pattern/设计模式基础.html" class="nav-link">设计模式</a></li><li class="dropdown-item"><!----> <a href="/data-structure/" class="nav-link">数据结构</a></li><li class="dropdown-item"><!----> <a href="/network-and-security/" class="nav-link">网络与安全</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">系统与工具</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/linux/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/mac/Homebrew.html" class="nav-link">Mac</a></li><li class="dropdown-item"><!----> <a href="/gradle/" class="nav-link">Gradle</a></li><li class="dropdown-item"><!----> <a href="/docker/" class="nav-link">Docker</a></li><li class="dropdown-item"><!----> <a href="/tool/" class="nav-link">其他</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">多媒体</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/opencv/搭建OpenCV Android项目.html" class="nav-link">OpenCV</a></li><li class="dropdown-item"><!----> <a href="/ffmpeg/macOS上编译FFmpeg.html" class="nav-link">FFmpeg</a></li></ul></div></div><div class="nav-item"><a href="/about-me/" class="nav-link">关于我</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/kotlin/Kotlin语法基础.html" class="sidebar-link">Kotlin语法基础</a></li><li><a href="/kotlin/函数的定义与调用.html" class="sidebar-link">函数的定义与调用</a></li><li><a href="/kotlin/类、对象和接口.html" class="active sidebar-link">类、对象和接口</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/kotlin/类、对象和接口.html#kotlin接口" class="sidebar-link">Kotlin接口</a></li><li class="sidebar-sub-header"><a href="/kotlin/类、对象和接口.html#访问修饰符" class="sidebar-link">访问修饰符</a></li><li class="sidebar-sub-header"><a href="/kotlin/类、对象和接口.html#可见性修饰符" class="sidebar-link">可见性修饰符</a></li><li class="sidebar-sub-header"><a href="/kotlin/类、对象和接口.html#内部类和嵌套类" class="sidebar-link">内部类和嵌套类</a></li><li class="sidebar-sub-header"><a href="/kotlin/类、对象和接口.html#密封类" class="sidebar-link">密封类</a></li><li class="sidebar-sub-header"><a href="/kotlin/类、对象和接口.html#类的构造方法" class="sidebar-link">类的构造方法</a></li><li class="sidebar-sub-header"><a href="/kotlin/类、对象和接口.html#类的属性" class="sidebar-link">类的属性</a></li><li class="sidebar-sub-header"><a href="/kotlin/类、对象和接口.html#通用对象方法" class="sidebar-link">通用对象方法</a></li><li class="sidebar-sub-header"><a href="/kotlin/类、对象和接口.html#数据类" class="sidebar-link">数据类</a></li><li class="sidebar-sub-header"><a href="/kotlin/类、对象和接口.html#类委托" class="sidebar-link">类委托</a></li><li class="sidebar-sub-header"><a href="/kotlin/类、对象和接口.html#object关键字" class="sidebar-link">object关键字</a></li></ul></li><li><a href="/kotlin/Lambda编程.html" class="sidebar-link">Lambda编程</a></li><li><a href="/kotlin/Kotlin的类型系统.html" class="sidebar-link">Kotlin的类型系统</a></li><li><a href="/kotlin/运算符重载及其他约定.html" class="sidebar-link">运算符重载及其他约定</a></li><li><a href="/kotlin/高阶函数.html" class="sidebar-link">高阶函数</a></li><li><a href="/kotlin/注解.html" class="sidebar-link">注解</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="类、对象和接口"><a href="#类、对象和接口" aria-hidden="true" class="header-anchor">#</a> 类、对象和接口</h1> <p></p><div class="table-of-contents"><ul><li><a href="#kotlin接口">Kotlin接口</a></li><li><a href="#访问修饰符">访问修饰符</a></li><li><a href="#可见性修饰符">可见性修饰符</a></li><li><a href="#内部类和嵌套类">内部类和嵌套类</a></li><li><a href="#密封类">密封类</a></li><li><a href="#类的构造方法">类的构造方法</a><ul><li><a href="#主-从构造方法">主/从构造方法</a></li><li><a href="#主构造方法和初始化语句块">主构造方法和初始化语句块</a></li><li><a href="#多个构造方法">多个构造方法</a></li></ul></li><li><a href="#类的属性">类的属性</a><ul><li><a href="#属性的声明">属性的声明</a></li><li><a href="#访问器与支持字段">访问器与支持字段</a></li><li><a href="#访问器的可见性">访问器的可见性</a></li><li><a href="#相同的jvm签名">相同的JVM签名</a></li></ul></li><li><a href="#通用对象方法">通用对象方法</a><ul><li><a href="#tostring">toString()</a></li><li><a href="#equals">equals()</a></li><li><a href="#hashcode">hashCode()</a></li></ul></li><li><a href="#数据类">数据类</a><ul><li><a href="#数据类的作用">数据类的作用</a></li><li><a href="#数据类的要求">数据类的要求</a></li></ul></li><li><a href="#类委托">类委托</a></li><li><a href="#object关键字">object关键字</a><ul><li><a href="#对象声明">对象声明</a></li><li><a href="#伴生对象">伴生对象</a></li><li><a href="#伴生对象实现工厂模式">伴生对象实现工厂模式</a></li><li><a href="#命名伴生对象">命名伴生对象</a></li><li><a href="#伴生对象和静态成员">伴生对象和静态成员</a></li><li><a href="#伴生对象实现接口">伴生对象实现接口</a></li><li><a href="#伴生对象扩展">伴生对象扩展</a></li><li><a href="#对象表达式">对象表达式</a></li></ul></li></ul></div><p></p> <h2 id="kotlin接口"><a href="#kotlin接口" aria-hidden="true" class="header-anchor">#</a> Kotlin接口</h2> <p>使用<code>interface</code>关键字声明一个Kotlin接口。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">interface</span> Clickable <span class="token punctuation">{</span>
    <span class="token keyword">fun</span> <span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Kotlin实现接口是在类名后面使用<code>:</code>来代替Java中的<code>implements</code>关键字。接口继承也是用<code>:</code>来代替<code>extends</code>关键字。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> Button <span class="token operator">:</span> Clickable <span class="token punctuation">{</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>override</code>修饰符用来标注被重写的父类或接口的方法或属性。不同于Java中的<code>@Override</code>注解，Kotlin的<code>override</code>修饰符是强制要求的。</p> <p>接口的方法可以有一个<strong>默认实现</strong>。这个实现不需要特殊注解，只需要提供一个方法体。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">interface</span> Clickable <span class="token punctuation">{</span>
    <span class="token keyword">fun</span> <span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">fun</span> <span class="token function">showOff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;showOff&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果某个类实现了多个接口，而这些接口有同名的默认方法，那么Kotlin编译器强制要求这个类要提供自己的实现。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">interface</span> Focusable <span class="token punctuation">{</span>
    <span class="token keyword">fun</span> <span class="token function">setFocus</span><span class="token punctuation">(</span>b<span class="token operator">:</span> Boolean<span class="token punctuation">)</span> <span class="token operator">=</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;${if (b) &quot;</span>got<span class="token string">&quot; else &quot;</span>lost<span class="token string">&quot;}&quot;</span><span class="token punctuation">)</span>
    
    <span class="token keyword">fun</span> <span class="token function">showOff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;showOff&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> Button <span class="token operator">:</span> Clickable<span class="token punctuation">,</span> Focusable <span class="token punctuation">{</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;clicked&quot;</span><span class="token punctuation">)</span>
    
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">showOff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token operator">&lt;</span>Clickable<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token function">showOff</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">super</span><span class="token operator">&lt;</span>Focusable<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token function">showOff</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>可通过<code>super&lt;父类/接口名&gt;.方法名()</code>来调用父类或接口的方法。</p> <p>Kotlin1.0是以Java6为目标设计的，其并不支持接口中的默认方法。因此，它会把每个带默认方法的接口编译成一个普通接口和一个将方法体作为静态函数的类的结合体。</p> <h2 id="访问修饰符"><a href="#访问修饰符" aria-hidden="true" class="header-anchor">#</a> 访问修饰符</h2> <table><thead><tr><th>修饰符</th> <th>相关成员</th> <th>说明</th></tr></thead> <tbody><tr><td>final</td> <td>不能被重写</td> <td>类中成员默认使用</td></tr> <tr><td>open</td> <td>可以被重写</td> <td>需要明确地表明</td></tr> <tr><td>abstract</td> <td>必须被重写</td> <td>只能在抽象类中声明；抽象成员始终是open的。</td></tr> <tr><td>override</td> <td>重写父类或接口中的成员</td> <td>如果没有使用final表明，重写的成员默认是open的。</td></tr></tbody></table> <p>Java的类和方法默认是<code>open</code>的，而Kotlin中默认都是<code>final</code>。</p> <p>在Kotlin中，和Java一样，可以将一个类声明为<code>abstract</code>。这种类被称作抽象类，它是不能被实例化的，它通常包含一些没有实现并且必须在子类重写的抽象成员。抽象成员是不能有实现的。</p> <h2 id="可见性修饰符"><a href="#可见性修饰符" aria-hidden="true" class="header-anchor">#</a> 可见性修饰符</h2> <p>Kotlin的可见性修饰符与Java的类似，同样是<code>public</code>、<code>protected</code>和<code>private</code>。</p> <p>Kotlin只把包作为在命名空间里组织代码的一种方式，并没有将其用作可见性控制。</p> <p>Kotlin新增了一个叫<code>internal</code>的修饰符，它表示“只在模块内部可见”。一个模块就是一组一起编译的Kotlin文件，它可能是一个Intellij IDEA模块、一个Eclipse项目、一个Maven或Gradle项目、一组使用Ant任务进行编译的文件等等。</p> <p>Java的默认可见性为包私有，而Kotlin默认为<code>public</code>。</p> <p>Kotlin允许在顶层声明中使用<code>private</code>可见性，包括类、函数和属性。这些声明就只会在声明它们的文件中可见。</p> <table><thead><tr><th>修饰符</th> <th>类成员</th> <th>顶层声明</th></tr></thead> <tbody><tr><td>public（默认）</td> <td>所有地方可见</td> <td>所有地方可见</td></tr> <tr><td>internal</td> <td>模块中可见</td> <td>模块中可见</td></tr> <tr><td>protected</td> <td>子类中可见</td> <td>X</td></tr> <tr><td>private</td> <td>类中可见</td> <td>文件中可见</td></tr></tbody></table> <p>注意<code>protected</code>修饰符在Java和Kotlin中的不同行为。</p> <ul><li><p>在Java中，可以从同一个包中、同一个类中和它的子类中访问一个<code>protected</code>成员。</p></li> <li><p>在Kotlin中，<code>protected</code>成员只在类和它的子类中可见。</p></li></ul> <p>记住一个通用的规则：类的基础类型和类型参数列表中用到的所有类，或者函数的签名都有与这个类或者函数本身相同的可见性。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">internal</span> <span class="token keyword">open</span> <span class="token keyword">class</span> TalkativeButton <span class="token operator">:</span> Focusable <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">yell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;yell&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">protected</span> <span class="token keyword">fun</span> <span class="token function">whisper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;whisper&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 错误：public成员暴露了internal的接收者类型</span>
<span class="token keyword">fun</span> TalkativeButton<span class="token punctuation">.</span><span class="token function">speech</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 错误：类的扩展函数不能访问它的private和protected成员</span>
    <span class="token function">yell</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">whisper</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="内部类和嵌套类"><a href="#内部类和嵌套类" aria-hidden="true" class="header-anchor">#</a> 内部类和嵌套类</h2> <p>内部类和嵌套类都是一个在另一个类的内部定义的类。区别在于内部类存储外部类的引用，而嵌套类没有。</p> <p>在Kotlin中，在类的内部定义的类默认为嵌套类。而Java默认为内部类。</p> <p>内部类和嵌套类在Java和Kotlin中的对应关系如下。</p> <table><thead><tr><th>类</th> <th>在Java中</th> <th>在Kotlin中</th></tr></thead> <tbody><tr><td>内部类</td> <td>class A</td> <td>inner class A</td></tr> <tr><td>嵌套类</td> <td>static class A</td> <td>class A</td></tr></tbody></table> <p>在Kotlin的内部类中，需要使用<code>this@外部类名</code>来访问外部类。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> Outer <span class="token punctuation">{</span>
    <span class="token keyword">inner</span> <span class="token keyword">class</span> Inner <span class="token punctuation">{</span>
        <span class="token keyword">fun</span> <span class="token function">getOuterReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Outer <span class="token operator">=</span> <span class="token keyword">this</span><span class="token label symbol">@Outer</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="密封类"><a href="#密封类" aria-hidden="true" class="header-anchor">#</a> 密封类</h2> <p>使用<code>sealed</code>修饰符标注的类叫作密封类。它对子类的创建有着严格的限制：所有的<strong>直接子类</strong>必须嵌套在父类中。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">sealed</span> <span class="token keyword">class</span> Expr <span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token function">Num</span><span class="token punctuation">(</span><span class="token keyword">val</span> value<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Expr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">class</span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token keyword">val</span> left<span class="token operator">:</span> Expr<span class="token punctuation">,</span> <span class="token keyword">val</span> right<span class="token operator">:</span> Expr<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Expr</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>注意，<code>sealed</code>修饰符隐含了这个类是一个<code>open</code>类，不再需要显式地添加<code>open</code>修饰符。</p> <p>如果你在<code>when</code>表达式中处理所有<code>sealed</code>类的子类，那么你就不再需要提供默认分支（<code>else -&gt;</code>分支）。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">fun</span> <span class="token function">eval</span><span class="token punctuation">(</span>e<span class="token operator">:</span> Expr<span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token operator">=</span> 
    <span class="token keyword">when</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">is</span> Expr<span class="token punctuation">.</span>Num <span class="token operator">-&gt;</span> e<span class="token punctuation">.</span>value
        <span class="token keyword">is</span> Expr<span class="token punctuation">.</span>Sum <span class="token operator">-&gt;</span> <span class="token function">eval</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">eval</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>当你在<code>when</code>中使用<code>sealed</code>类，并且<code>sealed</code>类添加了一个新的子类时，有返回值的<code>when</code>表达式会出现编译失败，编译器会告诉你需要在哪些<code>when</code>代码块中添加新增的<code>sealed</code>类的子类的判断分支。</p> <p>在Kotlin1.0中，<code>sealed</code>类的限制是相当严格的。例如，所有的子类必须是嵌套的，并且子类不能创建为data类。而Kotlin1.1解除了这些限制，并允许在<strong>同一个文件</strong>的任何位置定义<code>sealed</code>类的子类。</p> <h2 id="类的构造方法"><a href="#类的构造方法" aria-hidden="true" class="header-anchor">#</a> 类的构造方法</h2> <h3 id="主-从构造方法"><a href="#主-从构造方法" aria-hidden="true" class="header-anchor">#</a> 主/从构造方法</h3> <p>在Java中，一个类可以声明一个或多个构造方法。</p> <p>Kotlin区分主构造方法和从构造方法。</p> <ul><li><p>主构造方法是在类体外部声明，通常是主要而简洁的初始化类的方法。</p></li> <li><p>从构造方法是在类体内部声明的。</p></li></ul> <h3 id="主构造方法和初始化语句块"><a href="#主构造方法和初始化语句块" aria-hidden="true" class="header-anchor">#</a> 主构造方法和初始化语句块</h3> <p><code>constructor</code>关键字用来开始一个主构造方法或从构造方法的声明。主构造方法声明在类体外部，而从构造方法声明在类体内部。</p> <p><code>init</code>关键字用来引入一个初始化语句块，它包含了在类被创建时执行的代码。因为主构造方法有语法限制，不能包含初始化代码，所以常使用初始化语句块。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> User <span class="token keyword">constructor</span><span class="token punctuation">(</span>_nickname<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> nickname<span class="token operator">:</span> String
    
    <span class="token keyword">init</span> <span class="token punctuation">{</span>
        nickname <span class="token operator">=</span> _nickname
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>如果主构造方法没有注解或可见性修饰符，可以去掉<code>constructor</code>关键字。另外，这里可以直接用主构造方法的参数来初始化属性，从而去掉<code>init</code>代码块。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">User</span><span class="token punctuation">(</span>_nickname<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> nickname <span class="token operator">=</span> _nickname
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果属性用相应的构造方法参数来初始化，代码可以通过把<code>val</code>或<code>var</code>关键字加在该参数前进行简化。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">val</span> nickname<span class="token operator">:</span> String<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>可以像函数参数一样为构造方法参数声明一个默认值。另外，如果所有的构造方法参数都有默认值，编译器会生成一个额外的不带参数的构造方法来使用所有的默认值。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">val</span> nickname<span class="token operator">:</span> String<span class="token punctuation">,</span>
        <span class="token keyword">val</span> isSubscribed<span class="token operator">:</span> Boolean <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果你的类具有一个父类，主构造方法同样需要初始化父类。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">open</span> <span class="token keyword">class</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">val</span> nickname<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token function">GoogleUser</span><span class="token punctuation">(</span>nickname<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">User</span><span class="token punctuation">(</span>nickname<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果没有给一个类声明任何的构造方法，编译器会生成一个不做任何事情的默认构造方法。注意，它的子类必须显式地调用它的这个默认构造方法。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">open</span> <span class="token keyword">class</span> User <span class="token punctuation">{</span> <span class="token operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

<span class="token keyword">class</span> GoogleUser <span class="token operator">:</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可以将构造方法标记为<code>private</code>来确保类不被其他代码实例化。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> Secretive <span class="token keyword">private</span> <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="多个构造方法"><a href="#多个构造方法" aria-hidden="true" class="header-anchor">#</a> 多个构造方法</h3> <p>大多数在Java中需要重载构造方法的场景都被Kotlin支持参数默认值和参数命名的语法涵盖了。</p> <p>但还是会有需要多个构造方法的情景，最常见的是当你需要扩展一个框架类来提供多个构造方法，以便于通过不同的方式来初始化类。例如，Android的View类。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">open</span> <span class="token keyword">class</span> View <span class="token punctuation">{</span>
    <span class="token keyword">constructor</span><span class="token punctuation">(</span>ctx<span class="token operator">:</span> Context<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 从构造方法</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">constructor</span><span class="token punctuation">(</span>ctx<span class="token operator">:</span> Context<span class="token punctuation">,</span> attr<span class="token operator">:</span> AttributeSet<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 从构造方法</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>子类可以通过<code>super()</code>关键字来调用对应的父类构造方法。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> MyButton <span class="token operator">:</span> View <span class="token punctuation">{</span>
    <span class="token keyword">constructor</span><span class="token punctuation">(</span>ctx<span class="token operator">:</span> Context<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">super</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">constructor</span><span class="token punctuation">(</span>ctx<span class="token operator">:</span> Context<span class="token punctuation">,</span> attr<span class="token operator">:</span> AttributeSet<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">super</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> attr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>也可以使用<code>this()</code>关键字来从一个构造方法中调用同一个类中的另一个构造方法。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> MyButton <span class="token operator">:</span> View <span class="token punctuation">{</span>
    <span class="token keyword">constructor</span><span class="token punctuation">(</span>ctx<span class="token operator">:</span> Context<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> MY_STYLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">constructor</span><span class="token punctuation">(</span>ctx<span class="token operator">:</span> Context<span class="token punctuation">,</span> attr<span class="token operator">:</span> AttributeSet<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">super</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> attr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>如果类没有主构造方法，那么每个从构造方法必须直接（<code>super()</code>）或间接（<code>this()</code>）地调用一个基类构造方法。</p> <h2 id="类的属性"><a href="#类的属性" aria-hidden="true" class="header-anchor">#</a> 类的属性</h2> <h3 id="属性的声明"><a href="#属性的声明" aria-hidden="true" class="header-anchor">#</a> 属性的声明</h3> <p>可以在主构造方法中直接声明一个属性。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">val</span> nickname<span class="token operator">:</span> String<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>也可以在类体内部声明一个属性。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> User <span class="token punctuation">{</span>
    <span class="token keyword">val</span> nickname<span class="token operator">:</span> String
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>通过<code>override</code>关键字来重写父类或接口的属性。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">interface</span> User <span class="token punctuation">{</span>
    <span class="token keyword">val</span> nickname<span class="token operator">:</span> String
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">PrivateUser</span><span class="token punctuation">(</span><span class="token keyword">override</span> <span class="token keyword">val</span> nickname<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">:</span> User

<span class="token keyword">class</span> <span class="token function">GoogleUser</span><span class="token punctuation">(</span><span class="token keyword">val</span> email<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">:</span> User <span class="token punctuation">{</span>
    <span class="token keyword">override</span> <span class="token keyword">val</span> nickname<span class="token operator">:</span> String
        <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> email<span class="token punctuation">.</span><span class="token function">substringBefore</span><span class="token punctuation">(</span><span class="token string">'@'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token function">FacebookUser</span><span class="token punctuation">(</span><span class="token keyword">val</span> account<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">:</span> User <span class="token punctuation">{</span>
    <span class="token keyword">override</span> <span class="token keyword">val</span> nickname<span class="token operator">:</span> String <span class="token operator">=</span> account
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="访问器与支持字段"><a href="#访问器与支持字段" aria-hidden="true" class="header-anchor">#</a> 访问器与支持字段</h3> <p>在访问器的函数体中，可通过<code>field</code>标识符来访问支持字段。在<code>getter</code>中，只能读取<code>field</code>的值；而在<code>setter</code>中，既能读取它也能修改它。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> address<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string">&quot;unspecified&quot;</span>
        <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;<span class="token interpolation variable">$name</span>'s address was changed: <span class="token interpolation variable">$field</span> -&gt; <span class="token interpolation variable">$value</span>&quot;</span><span class="token punctuation">)</span>
            field <span class="token operator">=</span> value
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="访问器的可见性"><a href="#访问器的可见性" aria-hidden="true" class="header-anchor">#</a> 访问器的可见性</h3> <p>属性的访问器的可见性默认与属性的可见性相同，但可以在<code>set</code>和<code>get</code>关键字前放置可见性修饰符来修改对应访问器的可见性。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> Counter <span class="token punctuation">{</span>
    <span class="token keyword">var</span> count<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">private</span> <span class="token keyword">set</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="相同的jvm签名"><a href="#相同的jvm签名" aria-hidden="true" class="header-anchor">#</a> 相同的JVM签名</h3> <p>Kotlin在实现Java接口时，属性的访问器可能会跟Java接口定义的方法冲突，出现“相同的JVM签名”错误。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserDetails</span> <span class="token punctuation">{</span>
    String <span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token comment">// var username自动生成的getter与UserDetails接口定义的getUsername()，会因为JVM签名相同而报错</span>
<span class="token keyword">class</span> <span class="token function">Reader</span><span class="token punctuation">(</span><span class="token keyword">var</span> username<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span> <span class="token operator">:</span> UserDetails
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>解决方法是：用<code>private</code>声明属性，并手写实现Java接口的方法。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">Reader</span><span class="token punctuation">(</span><span class="token keyword">private</span> <span class="token keyword">var</span> username<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span> <span class="token operator">:</span> UserDetails <span class="token punctuation">{</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token operator">=</span> username
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="通用对象方法"><a href="#通用对象方法" aria-hidden="true" class="header-anchor">#</a> 通用对象方法</h2> <h3 id="tostring"><a href="#tostring" aria-hidden="true" class="header-anchor">#</a> toString()</h3> <p>和Java一样，Kotlin中的所有类都提供了一种方式来获取类对象的字符串表示形式。</p> <p>一个对象的字符串表示默认类似<code>User@5e9f23b4</code>，你可以重写它对应类的<code>toString()</code>来修改。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">val</span> nickname<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">&quot;User(nickname=<span class="token interpolation variable">$nickname</span>)&quot;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="equals"><a href="#equals" aria-hidden="true" class="header-anchor">#</a> equals()</h3> <p>使用<code>equals()</code>来比较两个对象是否相等。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">val</span> nickname<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">equals</span><span class="token punctuation">(</span>other<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">:</span> Boolean <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>other <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> other <span class="token operator">!</span><span class="token keyword">is</span> User<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> nickname <span class="token operator">==</span> other<span class="token punctuation">.</span>nickname
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在Java中，可以使用<code>==</code>运算符来比较基本数据类型（比较两者的值）和引用类型（比较两者的引用）。而在Kotlin中，<code>==</code>运算符是通过调用<code>equals()</code>来比较两个值；要想进行引用比较，需要使用<code>===</code>运算符。</p> <h3 id="hashcode"><a href="#hashcode" aria-hidden="true" class="header-anchor">#</a> hashCode()</h3> <p>调用对象的<code>hashCode()</code>获取它的hash值。子类需要遵循Java同样的规则来重写这个方法，否则会影响对象在Hash容器中的表现。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">val</span> id<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">31</span> <span class="token operator">+</span> id
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="数据类"><a href="#数据类" aria-hidden="true" class="header-anchor">#</a> 数据类</h2> <p>为类添加<code>data</code>修饰符来声明一个数据类。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">val</span> id<span class="token operator">:</span> Int<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="数据类的作用"><a href="#数据类的作用" aria-hidden="true" class="header-anchor">#</a> 数据类的作用</h3> <p>数据类为我们自动生成如下的东西：</p> <ul><li><p><code>equals()</code>和<code>hashCode()</code></p></li> <li><p><code>toString()</code></p></li> <li><p><code>componentN()</code></p></li> <li><p><code>copy()</code></p></li></ul> <p>通常将数据类的所有属性都声明为<code>val</code>，使它的实例不可变。然后外界通过数据类的<code>copy()</code>来获得该实例的一个副本。普通的不可变类也可以手动实现一个<code>copy</code>函数。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">val</span> id<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">fun</span> <span class="token function">copy</span><span class="token punctuation">(</span>name<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span>
            id<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">User</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> id<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="数据类的要求"><a href="#数据类的要求" aria-hidden="true" class="header-anchor">#</a> 数据类的要求</h3> <p>主构造函数必须至少有一个参数。</p> <p>主构造函数中的所有参数必须被标记为<code>val</code>或<code>var</code>。虽然数据类的属性可以是<code>var</code>，但强烈推荐只使用<code>val</code>属性，让数据类的实例不可变。</p> <p>数据类不能有以下修饰符：<code>abstract</code>、<code>inner</code>、<code>open</code>和<code>sealed</code>等。</p> <p>在Kotlin1.1之前，数据类只能实现接口。从Kotlin1.1开始，数据类也可以继承其他类。</p> <h2 id="类委托"><a href="#类委托" aria-hidden="true" class="header-anchor">#</a> 类委托</h2> <p>在Java中，可通过装饰者模式来为一个类添加一些行为。这种模式的本质是：</p> <ul><li><p>创建一个新类，实现与原始类一样的接口，并将原始类的实例作为字段保存。</p></li> <li><p>这个新类可添加新的方法来支持新的行为。</p></li> <li><p>而与原始类拥有同样行为的方法不用被修改，只需要直接转发到原始类的实例上即可。</p></li></ul> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> DelegatingCollection<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">:</span> Collection<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">val</span> innerList <span class="token operator">=</span> arrayListOf<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    
    <span class="token keyword">override</span> <span class="token keyword">val</span> size<span class="token operator">:</span> Int <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> innerList<span class="token punctuation">.</span>size
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Boolean <span class="token operator">=</span> innerList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">contains</span><span class="token punctuation">(</span>element<span class="token operator">:</span> T<span class="token punctuation">)</span><span class="token operator">:</span> Boolean <span class="token operator">=</span> innerList<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Iterator<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">=</span> innerList<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">containsAll</span><span class="token punctuation">(</span>elements<span class="token operator">:</span> Collection<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> Boolean <span class="token operator">=</span> 
        innerList<span class="token punctuation">.</span><span class="token function">containsAll</span><span class="token punctuation">(</span>elements<span class="token punctuation">)</span>
        
    <span class="token comment">// 定义新行为...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>按照Java做法来实现会出现相当多的样板代码，幸好Kotlin将<strong>委托</strong>作为一个语言级别的功能做了头等支持。可以使用<code>by</code>关键字将接口的实现委托给另一个对象，编译器会自动实现接口的方法并在方法的内部调用被委托对象的对应方法。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> DelegatingCollection<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>
    innerList<span class="token operator">:</span> Collection<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">=</span> arrayListOf<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token operator">:</span> Collection<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token keyword">by</span> innerList <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="object关键字"><a href="#object关键字" aria-hidden="true" class="header-anchor">#</a> object关键字</h2> <p>常用<code>object</code>关键字来实现以下场景：</p> <ul><li><p><strong>对象声明</strong>。这是定义单例的一种方式。</p></li> <li><p><strong>伴生对象</strong>。它可以持有工厂方法、与这个类相关但在调用时并不依赖类实例的方法。</p></li> <li><p><strong>对象表达式</strong>。用来替代Java的匿名内部类。</p></li></ul> <p><code>object</code>实现的这些场景都遵循着一个核心理念：<code>object</code>关键字定义一个类并同时创建一个实例。</p> <h3 id="对象声明"><a href="#对象声明" aria-hidden="true" class="header-anchor">#</a> 对象声明</h3> <p>Kotlin使用对象声明为单例模式提供了最高级的语言支持。对象声明将类声明与该类的单一实例声明结合在一起。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">object</span> Payroll
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Payroll</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Payroll INSTANCE<span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        Payroll var0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Payroll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        INSTANCE <span class="token operator">=</span> var0<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>与类一样，一个对象声明也可以包含属性、方法、初始化语句块等声明。<strong>唯一不允许的就是构造方法</strong>。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">object</span> Payroll <span class="token punctuation">{</span>
    <span class="token keyword">val</span> allEmployees <span class="token operator">=</span> arrayListOf<span class="token operator">&lt;</span>Person<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    
    <span class="token keyword">fun</span> <span class="token function">calculateSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>person <span class="token keyword">in</span> allEmployees<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// ...</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>与变量一样，对象声明允许你使用<code>对象名.</code>来调用方法和访问属性。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code>Payroll<span class="token punctuation">.</span>allEmployees<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token operator">..</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

Payroll<span class="token punctuation">.</span><span class="token function">calculateSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>对象声明同样<strong>可以继承自类和接口</strong>。</p> <p>可以在任何可以使用普通对象的地方使用单例对象。</p> <p>可以在一个类的内部声明对象。这样的对象同样只有单一实例，不会在每个容器类的实例中具有不同的实例。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用对象声明定义的名称比较器是一个单例</span>
    <span class="token keyword">object</span> NameComparator<span class="token operator">:</span> Comparator<span class="token operator">&lt;</span>Person<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">compare</span><span class="token punctuation">(</span>p1<span class="token operator">:</span> Person<span class="token punctuation">,</span> p2<span class="token operator">:</span> Person<span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token operator">=</span> 
            p1<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Kotlin中的对象声明会<strong>被编译成通过静态字段来持有它的单一实例的类</strong>，这个字段名为<code>INSTANCE</code>。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>NameComparator<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="伴生对象"><a href="#伴生对象" aria-hidden="true" class="header-anchor">#</a> 伴生对象</h3> <p>Kotlin中的类<strong>不能拥有静态成员</strong>，Java的<code>static</code>关键字并不是Kotlin语言的一部分。作为替代，Kotlin依赖<strong>包级别函数</strong>和<strong>对象声明</strong>。</p> <ul><li><p>包级别函数，即顶层函数，在大多数情形下能够替代Java的静态方法。</p></li> <li><p>对象声明能够替代Java的静态方法和静态字段。</p></li></ul> <p>在大多数情况下，还是推荐使用顶层函数，但它不能访问类的<code>private</code>和<code>protected</code>成员。</p> <p>在类的内部定义的对象声明，可以加上<code>companion</code>关键字使其变成<strong>伴生对象</strong>。这样做的好处是：不再需要显式地指明对象的名称，可以直接通过容器类名称来访问这个对象的方法和属性。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> A <span class="token punctuation">{</span>
    <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token punctuation">{</span>
        <span class="token keyword">fun</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;companion object called&quot;</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code>A<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注意，类的伴生对象成员在子类中<strong>不能被重写</strong>。</p> <h3 id="伴生对象实现工厂模式"><a href="#伴生对象实现工厂模式" aria-hidden="true" class="header-anchor">#</a> 伴生对象实现工厂模式</h3> <p>伴生对象可以访问类中的<code>private</code>成员，包括<code>private</code>构造方法，它是实现工厂模式的理想选择。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> User <span class="token keyword">private</span> <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">val</span> nickname<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token punctuation">{</span>
        <span class="token keyword">fun</span> <span class="token function">newSubscribingUser</span><span class="token punctuation">(</span>email<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">User</span><span class="token punctuation">(</span>email<span class="token punctuation">.</span><span class="token function">substringBefore</span><span class="token punctuation">(</span><span class="token string">'@'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        
        <span class="token keyword">fun</span> <span class="token function">newFacebookUser</span><span class="token punctuation">(</span>account<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">User</span><span class="token punctuation">(</span>account<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="命名伴生对象"><a href="#命名伴生对象" aria-hidden="true" class="header-anchor">#</a> 命名伴生对象</h3> <p>伴生对象不需要显式地指明名称，默认分配为<strong>Companion</strong>。但若需要，可以显式地对它进行命名。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">companion</span> <span class="token keyword">object</span> Loader <span class="token punctuation">{</span>
        <span class="token keyword">fun</span> <span class="token function">fromJson</span><span class="token punctuation">(</span>jsonText<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> Person <span class="token operator">=</span> <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code>Person<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span><span class="token string">&quot;{name: 'daking'}&quot;</span><span class="token punctuation">)</span>

Person<span class="token punctuation">.</span>Loader<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span><span class="token string">&quot;{name: 'daking'}&quot;</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="伴生对象和静态成员"><a href="#伴生对象和静态成员" aria-hidden="true" class="header-anchor">#</a> 伴生对象和静态成员</h3> <p>类的伴生对象会被编译成常规对象：类中的一个引用了它的实例的静态字段。</p> <p>如果伴生对象没有命名，在Java代码中可通过<strong>Companion</strong>引用来访问；如果伴生对象有名字，那就用这个名字来替代Companion。</p> <p>Java需要类中的成员是静态的，Kotlin可以在对应的成员上使用<code>@JvmStatic</code>注解来达到这个目的。可以在一个顶层属性或者声明在object中的属性上使用<code>@JvmField</code>注解来声明一个<code>static</code>字段。</p> <p>Kotlin可以使用与Java相同的语法来访问Java类中声明的静态方法和字段。</p> <h3 id="伴生对象实现接口"><a href="#伴生对象实现接口" aria-hidden="true" class="header-anchor">#</a> 伴生对象实现接口</h3> <p>伴生对象可以实现接口，并且可以直接将包含它的类的名称当作实现了该接口的对象实例来使用。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">interface</span> JSONFactory<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">fun</span> <span class="token function">fromJson</span><span class="token punctuation">(</span>jsonText<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> T
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token operator">:</span> JSONFactory<span class="token operator">&lt;</span>Person<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">fromJson</span><span class="token punctuation">(</span>jsonText<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> Person <span class="token operator">=</span> <span class="token operator">..</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">fun</span> loadFromJson<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>factory<span class="token operator">:</span> JSONFactory<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token punctuation">{</span> <span class="token operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token function">loadFromJson</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span> <span class="token comment">// 直接将Person的名字作为JSONFactory的实例</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="伴生对象扩展"><a href="#伴生对象扩展" aria-hidden="true" class="header-anchor">#</a> 伴生对象扩展</h3> <p>可以为伴生对象定义一个扩展函数，使包含它的类具有新的行为。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fun</span> Person<span class="token punctuation">.</span>Companion<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>jsonText<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> Person <span class="token punctuation">{</span>
    <span class="token operator">..</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code><span class="token keyword">val</span> p <span class="token operator">=</span> Person<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>jsonText<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="对象表达式"><a href="#对象表达式" aria-hidden="true" class="header-anchor">#</a> 对象表达式</h3> <p><code>object</code>关键字不仅能用来声明单例式的对象，还能用来声明<strong>匿名对象</strong>。匿名对象替代了Java中匿名内部类的用法。</p> <div class="language-kotlin line-numbers-mode"><pre class="language-kotlin"><code>window<span class="token punctuation">.</span><span class="token function">addMouseListener</span> <span class="token punctuation">{</span>
    <span class="token keyword">object</span> <span class="token operator">:</span> <span class="token function">MouseAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">mouseClicked</span><span class="token punctuation">(</span>e<span class="token operator">:</span> MouseEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// ...</span>
        <span class="token punctuation">}</span>
        
        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">mouseEntered</span><span class="token punctuation">(</span>e<span class="token operator">:</span> MouseEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// ...</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>与对象声明不同，匿名对象不是单例的。每次对象表达式被执行都会创建一个新的对象实例。其实，<strong>匿名对象本质上是定义一个匿名类并同时创建一个实例</strong>。</p> <p>与Java匿名内部类只能扩展一个类或实现一个接口不同，Kotlin的<strong>匿名对象可以实现多个接口或不实现接口</strong>。</p> <p>与Java的匿名类一样，在对象表达式中可访问创建它的函数中的变量。但与Java不同，访问并没有被限制在final变量，还可以在对象表达式中修改变量的值。</p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/66.24bd90de.js" defer></script><script src="/assets/js/app.bb1fe17d.js" defer></script>
  </body>
</html>
