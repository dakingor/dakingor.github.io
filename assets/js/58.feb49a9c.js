(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{202:function(a,v,t){"use strict";t.r(v);var r=t(0),_=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,v=a.$createElement,t=a._self._c||v;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"垃圾收集"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集","aria-hidden":"true"}},[a._v("#")]),a._v(" 垃圾收集")]),a._v(" "),t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#概述"}},[a._v("概述")])]),t("li",[t("a",{attrs:{href:"#对象的存活"}},[a._v("对象的存活")]),t("ul",[t("li",[t("a",{attrs:{href:"#引用计数法"}},[a._v("引用计数法")])]),t("li",[t("a",{attrs:{href:"#可达性分析法"}},[a._v("可达性分析法")])]),t("li",[t("a",{attrs:{href:"#对象的引用"}},[a._v("对象的引用")])]),t("li",[t("a",{attrs:{href:"#finalize方法"}},[a._v("finalize方法")])]),t("li",[t("a",{attrs:{href:"#回收方法区"}},[a._v("回收方法区")])])])]),t("li",[t("a",{attrs:{href:"#垃圾收集算法"}},[a._v("垃圾收集算法")]),t("ul",[t("li",[t("a",{attrs:{href:"#标记-清除算法"}},[a._v("标记-清除算法")])]),t("li",[t("a",{attrs:{href:"#复制算法"}},[a._v("复制算法")])]),t("li",[t("a",{attrs:{href:"#标记-整理算法"}},[a._v("标记-整理算法")])]),t("li",[t("a",{attrs:{href:"#分代收集算法"}},[a._v("分代收集算法")])])])]),t("li",[t("a",{attrs:{href:"#内存分配策略"}},[a._v("内存分配策略")]),t("ul",[t("li",[t("a",{attrs:{href:"#对象优先在eden分配"}},[a._v("对象优先在Eden分配")])]),t("li",[t("a",{attrs:{href:"#大对象直接进入老年代"}},[a._v("大对象直接进入老年代")])]),t("li",[t("a",{attrs:{href:"#长期存活对象进入老年代"}},[a._v("长期存活对象进入老年代")])]),t("li",[t("a",{attrs:{href:"#动态对象年龄判定"}},[a._v("动态对象年龄判定")])]),t("li",[t("a",{attrs:{href:"#空间分配担保"}},[a._v("空间分配担保")])])])])])]),t("p"),a._v(" "),t("h2",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述","aria-hidden":"true"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),t("p",[a._v("Java运行时数据区域中的程序计数器、虚拟机栈、本地方法栈的生命周期是与所属的线程相同，即这些区域随线程而生，随线程而灭。")]),a._v(" "),t("p",[a._v("虚拟机栈和本地方法栈中的栈帧随着方法的进入和退出而有条不絮地执行入栈和出栈。而每一个栈帧要分配的内存大小基本上是在类结构确定时就已知。")]),a._v(" "),t("p",[a._v("因此，这3个区域的内存分配和回收都具备确定性，在它们身上无需过多地考虑内存回收的问题。")]),a._v(" "),t("p",[t("strong",[a._v("Java堆")]),a._v("和"),t("strong",[a._v("方法区")]),a._v("的内存分配和回收是动态的。比如，一个接口中的多个实现类需要的内存可能不一样、一个方法中的多个分支需要的内存也可能不一样、只有在运行期间才能知道要创建哪些对象。垃圾收集器所关注的就是这2个区域的内存。")]),a._v(" "),t("h2",{attrs:{id:"对象的存活"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象的存活","aria-hidden":"true"}},[a._v("#")]),a._v(" 对象的存活")]),a._v(" "),t("h3",{attrs:{id:"引用计数法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引用计数法","aria-hidden":"true"}},[a._v("#")]),a._v(" 引用计数法")]),a._v(" "),t("p",[a._v("给对象中添加一个引用计数器，每当有一个地方引用它，计数器值就加1；当引用失效时，计数器值就减1；任何时刻，计数器为0的对象就是不可能再被使用的。")]),a._v(" "),t("p",[a._v("引用计数法（Reference Counting）的实现简单且判定效率很高，但它很难解决对象之间相互循环引用的问题。")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[a._v("objA"),t("span",{attrs:{class:"token punctuation"}},[a._v(".")]),a._v("instance "),t("span",{attrs:{class:"token operator"}},[a._v("=")]),a._v(" objB"),t("span",{attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\nobjB"),t("span",{attrs:{class:"token punctuation"}},[a._v(".")]),a._v("instance "),t("span",{attrs:{class:"token operator"}},[a._v("=")]),a._v(" objA"),t("span",{attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\nobjA "),t("span",{attrs:{class:"token operator"}},[a._v("=")]),a._v(" null"),t("span",{attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\nobjB "),t("span",{attrs:{class:"token operator"}},[a._v("=")]),a._v(" null"),t("span",{attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br")])]),t("h3",{attrs:{id:"可达性分析法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可达性分析法","aria-hidden":"true"}},[a._v("#")]),a._v(" 可达性分析法")]),a._v(" "),t("p",[a._v("此算法的基本思路是：通过一系列被称为“GC Root”的对象作为起始点，从这些点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象不可用。即只要对象到GC Roots是不可达的，就判定它为可回收的对象。")]),a._v(" "),t("p",[t("img",{attrs:{src:"/15232039892424/15232398548018.jpg",alt:"可达性分析-w370"}})]),a._v(" "),t("p",[a._v("在Java语言中，可作为GC Root的对象包括如下几种：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("方法区中常量引用的对象。")])]),a._v(" "),t("li",[t("p",[a._v("方法区中静态属性引用的对象。")])]),a._v(" "),t("li",[t("p",[a._v("虚拟机栈（栈帧中的本地变量表）中引用的对象。")])]),a._v(" "),t("li",[t("p",[a._v("本地方法栈中JNI（一般是Native方法）引用的对象。")])])]),a._v(" "),t("h3",{attrs:{id:"对象的引用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象的引用","aria-hidden":"true"}},[a._v("#")]),a._v(" 对象的引用")]),a._v(" "),t("p",[a._v("判断一个对象的存活，无论是通过引用计数法还是可达性分析法，都与对象的“引用”有关。")]),a._v(" "),t("p",[a._v("在JDK 1.2之前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。\n它无法描述这样的一种应用场景：当内存空间足够时，则将对象保留在内存中；若内存空间在进行垃圾收集后还非常紧张，则可以抛弃这个对象。")]),a._v(" "),t("p",[a._v("从JDK 1.2开始，Java对引用的概念进行了扩充，将引用按强度从大到小分为如下4种：")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("强引用（Strong Reference）：在程序代码中普遍存在，类似"),t("code",[a._v("Object obj = new Object()")]),a._v("这样的引用。只要强引用还在，垃圾收集器就不会回收掉这些对象。")])]),a._v(" "),t("li",[t("p",[a._v("软引用（Soft Reference）：在系统将要发生内存溢出异常之前，会把这些对象列入回收范围中进行第二次回收。")])]),a._v(" "),t("li",[t("p",[a._v("弱引用（Weak Reference）：被弱引用关联的对象只能生存到下一个垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉它。")])]),a._v(" "),t("li",[t("p",[a._v("虚引用（Phantom Reference）：它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联是为了能在这个对象被收集器回收时能收到一个系统通知。")])])]),a._v(" "),t("h3",{attrs:{id:"finalize方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#finalize方法","aria-hidden":"true"}},[a._v("#")]),a._v(" finalize方法")]),a._v(" "),t("p",[a._v("一个对象在被回收之前，至少要经历两次标记。")]),a._v(" "),t("p",[a._v("首先，如果对象在经过可达性分析后被判定为不可达的，那么它就会被"),t("strong",[a._v("第一次标记")]),a._v("。")]),a._v(" "),t("p",[a._v("随后会进行一次筛选，筛选的条件是此对象"),t("strong",[a._v("是否有必要执行"),t("code",[a._v("finalize()")])]),a._v("。当对象没有重写"),t("code",[a._v("finalize()")]),a._v("或者其"),t("code",[a._v("finalize()")]),a._v("之前已被虚拟机调用过，虚拟机就认为没有必要执行"),t("code",[a._v("finalize()")]),a._v("。")]),a._v(" "),t("p",[a._v("如果这个对象被判定为有必要执行"),t("code",[a._v("finalize()")]),a._v("，那么它就会被放置在一个叫做F-Queue的队列中，稍后虚拟机自动建立的、低优先级的Finalizer线程会执行这个队列中的各个对象的"),t("code",[a._v("finalize()")]),a._v("。")]),a._v(" "),t("p",[a._v("接着，GC会对F-Queue中的对象进行"),t("strong",[a._v("第二次标记")]),a._v("，如果对象在"),t("code",[a._v("finalize()")]),a._v("中使自己重新与GC Roots引用链建立关联，那么它将被移出“即将回收”集合，否则它会被第二次标记而即将回收。")]),a._v(" "),t("h3",{attrs:{id:"回收方法区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回收方法区","aria-hidden":"true"}},[a._v("#")]),a._v(" 回收方法区")]),a._v(" "),t("p",[a._v("方法区也常被称为永生代，它的垃圾收集主要回收：废弃常量和无用的类。")]),a._v(" "),t("p",[a._v("回收废弃常量与回收Java堆中的对象类似。以常量池中字面量的回收为例，如果没有任何String对象或其他地方引用常量池中的"),t("code",[a._v('"abc"')]),a._v("常量，这个常量会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也如此。")]),a._v(" "),t("p",[a._v("要判定一个类为“无用的类”需要同时满足下面3个条件：")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("该类的所有实例已被回收，即Java堆中不存在该类的任何实例。")])]),a._v(" "),t("li",[t("p",[a._v("加载该类的ClassLoader已被回收。")])]),a._v(" "),t("li",[t("p",[a._v("该类对应的"),t("code",[a._v("java.lang.Class")]),a._v("对象没被引用。")])])]),a._v(" "),t("p",[a._v("JVM规范中不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的性价比一般比较低。但在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景，都需要虚拟机具备类卸载的功能，以保证方法区不会溢出。")]),a._v(" "),t("h2",{attrs:{id:"垃圾收集算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集算法","aria-hidden":"true"}},[a._v("#")]),a._v(" 垃圾收集算法")]),a._v(" "),t("h3",{attrs:{id:"标记-清除算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标记-清除算法","aria-hidden":"true"}},[a._v("#")]),a._v(" 标记-清除算法")]),a._v(" "),t("p",[a._v("标记-清除算法（Mark-Sweep）分为“标记”和“清除“两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。")]),a._v(" "),t("p",[a._v("这个算法主要的缺点有两个：")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("效率问题。标记和清除两个过程的效率都不高。")])]),a._v(" "),t("li",[t("p",[a._v("空间问题。清除之后会产生大量不连续的内存碎片，碎片太多可能会导致之后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。")])])]),a._v(" "),t("p",[t("img",{attrs:{src:"/15232039892424/15232671438624.jpg",alt:"标记-清除算法-w471"}})]),a._v(" "),t("h3",{attrs:{id:"复制算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#复制算法","aria-hidden":"true"}},[a._v("#")]),a._v(" 复制算法")]),a._v(" "),t("p",[a._v("复制算法（Copying）将可用内存划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完，就将存活的对象复制到另一块上，然后再把之前已使用过的那一块的空间一次清理掉。")]),a._v(" "),t("p",[a._v("每次都是对内存的一半区域进行回收，内存分配时也不用考虑碎片等问题，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。")]),a._v(" "),t("p",[a._v("但这种算法实际上是将可用内存缩小为原来的一半。")]),a._v(" "),t("p",[t("img",{attrs:{src:"/15232039892424/15232670859238.jpg",alt:"复制算法-w469"}})]),a._v(" "),t("h3",{attrs:{id:"标记-整理算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标记-整理算法","aria-hidden":"true"}},[a._v("#")]),a._v(" 标记-整理算法")]),a._v(" "),t("p",[a._v("标记-整理算法（Mark-Compact）分为”标记“-”整理“-”清除“三个阶段：首先标记出所有需要回收的对象，接着让所有存活的对象都向一端移动，完成后统一回收所有被标记的对象。")]),a._v(" "),t("p",[t("img",{attrs:{src:"/15232039892424/15232673361803.jpg",alt:"标记-整理算法-w470"}})]),a._v(" "),t("h3",{attrs:{id:"分代收集算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分代收集算法","aria-hidden":"true"}},[a._v("#")]),a._v(" 分代收集算法")]),a._v(" "),t("p",[a._v("当前商业虚拟机的垃圾收集基本上都是采用”分代收集“算法（Generational Collection）。")]),a._v(" "),t("p",[a._v("该算法根据对象存活周期的不同将内存划分为几块，每块采用不同的垃圾收集算法。")]),a._v(" "),t("p",[a._v("一般是把Java堆分为"),t("strong",[a._v("新生代")]),a._v("和"),t("strong",[a._v("老年代")]),a._v("。在新生代中，每次垃圾收集时都有大批对象死去，只有少量存活，于是选用"),t("strong",[a._v("复制算法")]),a._v("。而在老年代中，对象存活率高，使用"),t("strong",[a._v("标记整理算法或标记清除算法")]),a._v("来进行回收。")]),a._v(" "),t("p",[a._v("新生代采用复制算法来进行内存回收，但因为新生代中的对象98%是朝生夕灭的，所以并不需要按照1:1来划分内存空间，而按照"),t("strong",[a._v("8:1:1")]),a._v("将内存划分为一个较大的Eden空间和两个较小的Survivor空间。")]),a._v(" "),t("p",[a._v("每次使用Eden空间和其中一块Survivor空间。当回收时，将Eden和Survivor中的存活对象一次性地复制到另一块Survivor空间上，最后清理掉Eden和之前用过的Survivor空间。")]),a._v(" "),t("p",[a._v("如果在回收时，预留的那块Survivor空间不够用时，会依赖老年代等其他内存来进行"),t("strong",[a._v("分配担保")]),a._v("，即把存活对象放置到担保的老年代等其他内存上。")]),a._v(" "),t("h2",{attrs:{id:"内存分配策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存分配策略","aria-hidden":"true"}},[a._v("#")]),a._v(" 内存分配策略")]),a._v(" "),t("p",[a._v("Minor GC：又称为新生代GC，指发生在新生代的垃圾收集动作。因为Java对象大多都具备朝生夕灭的特性，所以Minor GC会十分频繁，但幸好它的回收速度比较快。")]),a._v(" "),t("p",[a._v("Full GC：又称为Major GC，指发生在老年代的GC。Full GC经常会伴随着至少一次的Minor GC。Full GC的速度一般会比Minor GC慢10倍以上。")]),a._v(" "),t("h3",{attrs:{id:"对象优先在eden分配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象优先在eden分配","aria-hidden":"true"}},[a._v("#")]),a._v(" 对象优先在Eden分配")]),a._v(" "),t("p",[a._v("大多数情况下，对象在新生代Eden区中分配。")]),a._v(" "),t("p",[a._v("当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。")]),a._v(" "),t("h3",{attrs:{id:"大对象直接进入老年代"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#大对象直接进入老年代","aria-hidden":"true"}},[a._v("#")]),a._v(" 大对象直接进入老年代")]),a._v(" "),t("p",[a._v("所谓的大对象是指需要大量连续内存空间的Java对象，比如很长的字符串或数组。")]),a._v(" "),t("p",[a._v("虚拟机提供一个"),t("code",[a._v("-XX: PretenureSizeThreshold")]),a._v("参数，大于这个设置值的对象直接在老年代上分配，以避免在新生代的Eden区以及两个Survivor区之间发生大量的内存复制。")]),a._v(" "),t("h3",{attrs:{id:"长期存活对象进入老年代"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#长期存活对象进入老年代","aria-hidden":"true"}},[a._v("#")]),a._v(" 长期存活对象进入老年代")]),a._v(" "),t("p",[a._v("虚拟机给每个对象定义了一个对象年龄（Age）计数器。")]),a._v(" "),t("p",[a._v("如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳，将被移动到Survivor空间中，然后对象年龄设为1。")]),a._v(" "),t("p",[a._v("对象在Survivor区中每熬过一次Minor GC，年龄就增加1。当它的年龄增加到一定程度，就将会晋升到老年代中。")]),a._v(" "),t("p",[a._v("对象晋升老年代的年龄阈值，可以通过参数"),t("code",[a._v("-XX: MaxTenuringThreshold")]),a._v("设置，默认为15。")]),a._v(" "),t("h3",{attrs:{id:"动态对象年龄判定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态对象年龄判定","aria-hidden":"true"}},[a._v("#")]),a._v(" 动态对象年龄判定")]),a._v(" "),t("p",[a._v("如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄>=该年龄的对象就可以直接进入老年代，无需等到"),t("code",[a._v("MaxTenuringThreshold")]),a._v("中要求的年龄。")]),a._v(" "),t("h3",{attrs:{id:"空间分配担保"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#空间分配担保","aria-hidden":"true"}},[a._v("#")]),a._v(" 空间分配担保")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("在发生Minor GC之前，虚拟机会先检查"),t("strong",[a._v("老年代最大可用的连续空间是否大于新生代所有对象的总空间")]),a._v("，如果条件成立，那么Minor GC就可以确保是安全的。否则进行下一步。")])]),a._v(" "),t("li",[t("p",[a._v("虚拟机会查看"),t("code",[a._v("HandlePromotionFailure")]),a._v("参数值"),t("strong",[a._v("是否允许担保失败")]),a._v("。如果不允许，就进行Full GC。如果允许，则进行下一步。")])]),a._v(" "),t("li",[t("p",[a._v("检查"),t("strong",[a._v("老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小")]),a._v("。如果大于，则冒险进行Minor GC。如果小于，则进行Full GC。")])])])])}],!1,null,null,null);_.options.__file="垃圾收集.md";v.default=_.exports}}]);