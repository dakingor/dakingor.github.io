(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{195:function(a,v,t){"use strict";t.r(v);var r=t(0),_=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,v=a.$createElement,t=a._self._c||v;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"java内存区域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java内存区域","aria-hidden":"true"}},[a._v("#")]),a._v(" Java内存区域")]),a._v(" "),t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#jvm内存区域"}},[a._v("JVM内存区域")]),t("ul",[t("li",[t("a",{attrs:{href:"#程序计数器"}},[a._v("程序计数器")])]),t("li",[t("a",{attrs:{href:"#java虚拟机栈"}},[a._v("Java虚拟机栈")])]),t("li",[t("a",{attrs:{href:"#本地方法栈"}},[a._v("本地方法栈")])]),t("li",[t("a",{attrs:{href:"#堆"}},[a._v("堆")])]),t("li",[t("a",{attrs:{href:"#方法区"}},[a._v("方法区")])]),t("li",[t("a",{attrs:{href:"#运行时常量池"}},[a._v("运行时常量池")])]),t("li",[t("a",{attrs:{href:"#直接内存"}},[a._v("直接内存")])]),t("li",[t("a",{attrs:{href:"#code-cache"}},[a._v("Code Cache")])])])]),t("li",[t("a",{attrs:{href:"#jvm内存区域与oom"}},[a._v("JVM内存区域与OOM")]),t("ul",[t("li",[t("a",{attrs:{href:"#java虚拟机栈"}},[a._v("Java虚拟机栈")])]),t("li",[t("a",{attrs:{href:"#堆"}},[a._v("堆")])]),t("li",[t("a",{attrs:{href:"#方法区"}},[a._v("方法区")])]),t("li",[t("a",{attrs:{href:"#直接内存"}},[a._v("直接内存")])])])]),t("li",[t("a",{attrs:{href:"#对象的创建、布局和访问"}},[a._v("对象的创建、布局和访问")]),t("ul",[t("li",[t("a",{attrs:{href:"#对象的创建"}},[a._v("对象的创建")])]),t("li",[t("a",{attrs:{href:"#对象的布局"}},[a._v("对象的布局")])]),t("li",[t("a",{attrs:{href:"#对象的访问"}},[a._v("对象的访问")])])])])])]),t("p"),a._v(" "),t("h2",{attrs:{id:"jvm内存区域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm内存区域","aria-hidden":"true"}},[a._v("#")]),a._v(" JVM内存区域")]),a._v(" "),t("p",[a._v("在"),t("strong",[a._v("JVM规范")]),a._v("中，在执行Java程序的过程中，JVM会把它所管理的内存划分为若干个不同的数据区域，分别为：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("程序计数器（Program Counter Register）")])]),a._v(" "),t("li",[t("p",[a._v("Java虚拟机栈（Java Virtual Machine Stack），简称Java栈")])]),a._v(" "),t("li",[t("p",[a._v("本地方法栈（Native Method Stack）")])]),a._v(" "),t("li",[t("p",[a._v("方法区（Method Area）")])]),a._v(" "),t("li",[t("p",[a._v("堆（Heap）")])])]),a._v(" "),t("p",[a._v("在实际开发应用中还有一些内存区域是"),t("strong",[a._v("不属于JVM规范")]),a._v("的，比如：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("直接内存（Direct Memory）")])]),a._v(" "),t("li",[t("p",[a._v("Code Cache")])])]),a._v(" "),t("p",[t("img",{attrs:{src:"/15231978412508/15305870916346.jpg",alt:""}})]),a._v(" "),t("p",[a._v("其中，有得区域是以线程为单位，而有的区域则是整个JVM进程唯一的。")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("以线程为单位的区域：程序计数器、虚拟机栈和本地方法栈。")])]),a._v(" "),t("li",[t("p",[a._v("以整个JVM进程唯一的区域：方法区、堆、直接内存和Code Cache等其他内存。")])])]),a._v(" "),t("h3",{attrs:{id:"程序计数器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器","aria-hidden":"true"}},[a._v("#")]),a._v(" 程序计数器")]),a._v(" "),t("p",[a._v("在JVM规范中，每个线程都有它自己的程序计数器（Program Counter Register），并且任何时间一个线程都只有一个方法在执行。")]),a._v(" "),t("p",[a._v("若线程正在执行的是一个Java方法，这个计数器记录的是正在执行的"),t("strong",[a._v("JVM字节码指令的地址")]),a._v("；若正在执行的是Native方法，该计数器记录值为空（Undefined）。")]),a._v(" "),t("h3",{attrs:{id:"java虚拟机栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java虚拟机栈","aria-hidden":"true"}},[a._v("#")]),a._v(" Java虚拟机栈")]),a._v(" "),t("p",[a._v("每个线程在创建时都会创建一个Java虚拟机栈，其内部保存一个个的"),t("strong",[a._v("栈帧")]),a._v("（Stack Frame），对应着一次次的Java方法调用。")]),a._v(" "),t("p",[a._v("每个方法被调用时都会创建一个栈帧，并压入虚拟机栈中，当方法执行完毕时，对应的栈帧会离开虚拟机栈。")]),a._v(" "),t("p",[a._v("在一个时间点，只有一个活动的栈帧，叫做"),t("strong",[a._v("当前帧")]),a._v("。对应方法所在的类叫做当前类。如果在该方法中调用了其他方法，对应的新的栈帧会被创建并成为新的当前帧。\ns\n栈帧存储着局部变量表、操作数栈、动态链接、方法出口（正常退出或异常退出）等信息。")]),a._v(" "),t("p",[a._v("局部变量表存放了编译器可知的各种基本数据类型、对象引用和returnAddress类型。它所需的内存空间在编译期间完成分配，在方法运行期间是不会改变的。")]),a._v(" "),t("h3",{attrs:{id:"本地方法栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈","aria-hidden":"true"}},[a._v("#")]),a._v(" 本地方法栈")]),a._v(" "),t("p",[a._v("本地方法栈与虚拟机栈类似，区别在于虚拟机栈支持对Java方法的调用，而本地方法栈是支持Native方法的。")]),a._v(" "),t("h3",{attrs:{id:"堆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆","aria-hidden":"true"}},[a._v("#")]),a._v(" 堆")]),a._v(" "),t("p",[a._v("堆是JVM所管理的内存中最大的一块，用来存放Java对象实例，几乎所有创建的Java对象实例都被直接分配在堆上。")]),a._v(" "),t("p",[a._v("堆是垃圾收集器管理的主要区域，因此也常被称为GC堆（Garbage Collected Heap）。")]),a._v(" "),t("p",[a._v("从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以堆还可以细分为新生代和老年代。新生代可再细分为Eden空间、From Survivor空间、To Survivor空间。")]),a._v(" "),t("p",[a._v("从内存分配的角度来看，堆可划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。")]),a._v(" "),t("p",[a._v("JVM规定堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。")]),a._v(" "),t("p",[a._v("堆既可以实现成固定大小，也可以是可扩展的。当前主流的虚拟机都是按照可扩展来实现，通过"),t("code",[a._v("-Xmx")]),a._v("和"),t("code",[a._v("-Xms")]),a._v("控制。")]),a._v(" "),t("h3",{attrs:{id:"方法区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法区","aria-hidden":"true"}},[a._v("#")]),a._v(" 方法区")]),a._v(" "),t("p",[a._v("方法区用于存储元数据（Metadata），如类结构信息以及对应的运行时常量池、字段、方法代码等。")]),a._v(" "),t("p",[a._v("JVM规定对方法区的限制非常宽松：除了和堆一样不需要连续的物理内存、大小可以固定或可扩展之外，它还可以选择不实现垃圾收集。")]),a._v(" "),t("p",[a._v("早期的Hotspot JVM在方法区中实现了永久代（Permanent Generation），但在Oracle JDK 8中将永久代移除，增加了元数据区（Metaspace）。")]),a._v(" "),t("h3",{attrs:{id:"运行时常量池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运行时常量池","aria-hidden":"true"}},[a._v("#")]),a._v(" 运行时常量池")]),a._v(" "),t("p",[t("strong",[a._v("运行时常量池")]),a._v("（Runtime Constant Pool）是方法区的一部分。")]),a._v(" "),t("p",[a._v("Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一个"),t("strong",[a._v("常量池")]),a._v("（Constant Pool Table），用它来存放编译器生成的各种字面量和符号引用。在类被加载后，其"),t("strong",[a._v("常量池")]),a._v("的内容会存放到"),t("strong",[a._v("运行时常量池")]),a._v("中。")]),a._v(" "),t("p",[a._v("相对于Class文件中的"),t("strong",[a._v("常量池")]),a._v("而言，"),t("strong",[a._v("运行时常量池")]),a._v("具备动态性。它不仅包含各个Class文件中的"),t("strong",[a._v("常量池")]),a._v("，还会在程序运行期间包含新的常量。")]),a._v(" "),t("h3",{attrs:{id:"直接内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#直接内存","aria-hidden":"true"}},[a._v("#")]),a._v(" 直接内存")]),a._v(" "),t("p",[a._v("直接内存（Direct Memory），也称为堆外内存，它并不是虚拟机运行时数据区的一部分，也不是JVM规范中定义的内存区域。")]),a._v(" "),t("p",[a._v("在JDK 1.4中新加入NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的IO方式。它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的"),t("code",[a._v("DirectByteBuffer")]),a._v("对象来作为这块堆外内存的引用。")]),a._v(" "),t("h3",{attrs:{id:"code-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#code-cache","aria-hidden":"true"}},[a._v("#")]),a._v(" Code Cache")]),a._v(" "),t("p",[a._v("JVM的JIT Compiler在运行时对热点代码进行编译，会将编译后的代码存储在Code Cache中。")]),a._v(" "),t("h2",{attrs:{id:"jvm内存区域与oom"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm内存区域与oom","aria-hidden":"true"}},[a._v("#")]),a._v(" JVM内存区域与OOM")]),a._v(" "),t("p",[a._v("从前面分析的JVM内存区域划分，除了程序计数器，其他区域都有可能会因为可能的空间不足发生OutOfMemoryError（OOM）。")]),a._v(" "),t("h3",{attrs:{id:"java虚拟机栈-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java虚拟机栈-2","aria-hidden":"true"}},[a._v("#")]),a._v(" Java虚拟机栈")]),a._v(" "),t("p",[a._v("如果编写一段程序不断地进行"),t("strong",[a._v("递归")]),a._v("，而且没有退出条件，就会导致不断地进行压栈，JVM会抛出"),t("strong",[a._v("StackOverFlowError")]),a._v("。如果JVM试图去扩展栈空间时失败，会抛出OOM。")]),a._v(" "),t("p",[a._v("本地方法栈类似。")]),a._v(" "),t("h3",{attrs:{id:"堆-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆-2","aria-hidden":"true"}},[a._v("#")]),a._v(" 堆")]),a._v(" "),t("p",[a._v("堆内存不足是导致OOM的最常见原因，其抛出的错误信息为"),t("code",[a._v("java.lang.OutOfMemoryError: Java heap space")]),a._v("。")]),a._v(" "),t("p",[a._v("因堆引起OOM的原因一般有以下几种情况：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("堆的大小设定不合理。")])]),a._v(" "),t("li",[t("p",[a._v("内存泄露。")])]),a._v(" "),t("li",[t("p",[a._v("JVM处理引用不及时，导致内存堆积。")])])]),a._v(" "),t("h3",{attrs:{id:"方法区-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法区-2","aria-hidden":"true"}},[a._v("#")]),a._v(" 方法区")]),a._v(" "),t("p",[a._v("早期的Hotspot JVM在方法区实现了永久代，因为永久代的大小是有限的，并且JVM对永久代的垃圾回收是非常不积极的，所以当程序不断添加新类型时，永久代也会出现OOM，其错误信息为"),t("code",[a._v("java.lang.OutOfMemoryError: PermGen space")]),a._v("。")]),a._v(" "),t("p",[a._v("在运行时存在大量动态类型生成、Intern字符串缓存占用太多等场合，更容易出现永久代OOM。")]),a._v(" "),t("p",[a._v("Oracle JDK 8中移除永久代，引入元数据区，方法区内存情况得到改善，但元数据区仍会引起OOM，其错误信息为"),t("code",[a._v("java.lang.OutOfMemoryError: Metaspace")]),a._v("。")]),a._v(" "),t("p",[a._v("运行时常量池是方法区的一部分，所以会受到方法区的内存限制。当运行时常量池无法再申请到内存时，将会抛出OOM。")]),a._v(" "),t("h3",{attrs:{id:"直接内存-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#直接内存-2","aria-hidden":"true"}},[a._v("#")]),a._v(" 直接内存")]),a._v(" "),t("p",[a._v("直接内存的分配不会受到Java堆的大小限制，但会受到本设备的总内存大小以及处理器寻址空间的限制，于是它也会可能抛出OOM。")]),a._v(" "),t("h2",{attrs:{id:"对象的创建、布局和访问"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象的创建、布局和访问","aria-hidden":"true"}},[a._v("#")]),a._v(" 对象的创建、布局和访问")]),a._v(" "),t("p",[a._v("探讨HotSpot虚拟机在Java堆中对象的创建、布局和访问的过程。")]),a._v(" "),t("h3",{attrs:{id:"对象的创建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象的创建","aria-hidden":"true"}},[a._v("#")]),a._v(" 对象的创建")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("类的加载：首先，JVM会检查new指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。若没有，那就先执行相应的类加载过程。")])]),a._v(" "),t("li",[t("p",[a._v("分配内存：在类加载检查通过后，JVM会为新生对象分配内存。\n假设Java堆中的内存是分成两边，一边是已用内存，另一边是空闲内存，那么就将中间的分割指针向空闲内存那边挪动，完成新生对象的内存分配。这做法叫做“指针碰撞”。\n如果Java堆中的内存的已用部分和空闲部分是相互交错的，只能通过JVM维护一个“空闲列表”，在该表上划分空间给新生对象。")])]),a._v(" "),t("li",[t("p",[a._v("分配内存时的线程安全：对分配内存空间的动作进行同步处理。也可以把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存（即Thread Local Allocation Buffer，TLAB），哪个线程需要分配内存，就在它的TLAB上进行分配，只有分配新的TLAB时才需要同步。")])]),a._v(" "),t("li",[t("p",[a._v("内存初始化：内存分配完成后，JVM会到分配到内存空间都初始化为零值。")])]),a._v(" "),t("li",[t("p",[a._v("对象的必要设置：JVM会对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）中。")])]),a._v(" "),t("li",[t("p",[t("code",[a._v("<init>")]),a._v("：执行完上面的new指令操作后，接着执行"),t("code",[a._v("<init>")]),a._v("方法。")])])]),a._v(" "),t("h3",{attrs:{id:"对象的布局"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象的布局","aria-hidden":"true"}},[a._v("#")]),a._v(" 对象的布局")]),a._v(" "),t("p",[a._v("对象在内存中存储的布局可分为3块区域：对象头（Object Header）、实例数据（Instance Data）和对齐填充（Padding）。")]),a._v(" "),t("p",[t("strong",[a._v("对象头")]),a._v("包括两部分信息：一是用于存储对象自身的"),t("strong",[a._v("运行时数据")]),a._v("，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。根据JVM的位数，使用32bit或64bit来表示这些信息。二是"),t("strong",[a._v("类型指针")]),a._v("，即指向对象的类元数据的指针。")]),a._v(" "),t("p",[a._v("另外，如果对象是一个数组，在对象头中还要"),t("strong",[a._v("记录数组的长度")]),a._v("。这是因为JVM可以通过普通Java对象的元数据信息确定对象的大小，但从数组的元数据无法确定其大小。")]),a._v(" "),t("p",[t("strong",[a._v("实例数据")]),a._v("是对象真正存储的有效信息。")]),a._v(" "),t("p",[t("strong",[a._v("对齐填充")]),a._v("仅仅是用于占位，并无特别的含义，也不是必然的存在。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是对象的大小必须是8字节的整数倍。而"),t("strong",[a._v("对象头")]),a._v("部分正好是8字节的倍数，但"),t("strong",[a._v("实例数据")]),a._v("部分可能没有对齐，此时就需要通过"),t("strong",[a._v("对齐填充")]),a._v("来对齐。")]),a._v(" "),t("h3",{attrs:{id:"对象的访问"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象的访问","aria-hidden":"true"}},[a._v("#")]),a._v(" 对象的访问")]),a._v(" "),t("p",[a._v("对象的访问主要有两种方式：句柄和直接指针。")]),a._v(" "),t("p",[t("strong",[a._v("句柄")]),a._v("访问方式：Java堆中将会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。")]),a._v(" "),t("p",[t("img",{attrs:{src:"/15231978412508/15232036146736.jpg",alt:"句柄访问方式"}})]),a._v(" "),t("p",[t("strong",[a._v("直接指针")]),a._v("访问方式：reference中存储的是对象地址，而Java堆中的对象的布局中要考虑如何放置访问类型数据的相关信息。")]),a._v(" "),t("p",[t("img",{attrs:{src:"/15231978412508/15232037122222.jpg",alt:"直接指针访问方式"}})]),a._v(" "),t("p",[a._v("这两种访问方式各有优劣：")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("使用"),t("strong",[a._v("句柄")]),a._v("的最大好处是reference存储的是稳定的句柄地址，在对象被移动时只需要改变句柄中的实例数据指针，而reference本身不需要修改。但"),t("strong",[a._v("句柄")]),a._v("多了一次指针定位的时间开销。")])]),a._v(" "),t("li",[t("p",[a._v("使用"),t("strong",[a._v("直接指针")]),a._v("的最大好处是速度更快，因为它节省了一次指针定位的时间开销。但在对象被移动时，reference本身需要修改。")])])])])}],!1,null,null,null);_.options.__file="Java内存区域.md";v.default=_.exports}}]);